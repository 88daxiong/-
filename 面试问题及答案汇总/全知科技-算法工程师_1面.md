# 全知科技-算法工程师1面

## 0x1 项目里面的CNN结构是什么样的？为什么要这么选？详细说一下卷积层、池化层、全连接层的作用。说一下在CNN反向传播的时候，**全连接层和卷积层是如何计算损失向前传播的**。

前两个问题可能存粹是因为CNN在图像上的效果比较好，所以这么选。以及为什么这个设计结构，只能简单的回答说这是CNN一个典型的结构，对于这一块我其实也不是特别清楚。

一个CNN说的典型结构： *输入→卷积→ReLU→卷积→ReLU→池化→ReLU→卷积→ReLU→池化→全连接*

### 1）卷积核作用

最后我们训练CNN卷积神经网络，最后训练得出来的东西其实就是这些卷积核的参数。当参数固定了之后，对于一张新的图片，就能判断出是属于什么了。

卷积核(Filter)也叫特征标识符，这些特征可以指直边缘，原色，曲线等等。卷积核本质上就是空间或时间上的加权求和。

### 2）卷积层

卷积层就是一个卷积核扫描后得到的一张图片，一张图片经过多少个卷积核，就会有多少张图片生成

## 3）池化层

Pooling层对于卷积层进行了个一个降维的操作。 Max Pooling是对一个卷积层抽取的特征值取最大的值作为这个层的保留值， 其他值全部抛弃，这个值代表了特征值种最显著的特征。他可以减少模型的参数数量，减少过拟合的问题。

### 4）全连接层

全连接层起到的是将学到的“分布式特征表示”映射到样本标记空间的作用。完全连接层观察高级特征和哪一分类最为吻合和拥有怎样的特定权重，因此当计算出权重与先前层之间的点积后，你将得到不同分类的正确概率。

参考1：https://www.jianshu.com/p/09f35a390ac2

参考2：https://blog.csdn.net/lee813/article/details/82141526

参考3：https://blog.csdn.net/moyu916/article/details/88627479

### 5）池化层反向传播

首先需要确定池化后的那个误差值是由原来4*4（池化大小）的哪个区域决定。如果是最大池化，我们只需要记录向前传播中最大值的位置，然后误差放回去即可。如果是平均池化，只需要将池化但愿的误差的平均值放回去原来的子矩阵即可。

### 6）卷积层的反向传播

核心点，卷积核的权重矩阵需要旋转180度。

参考：https://blog.csdn.net/qq_16137569/article/details/81477906



## 0x2 python的多线程和多进程是如何的，为什么会有多线程这个东西，说一下原理。python的多线程是真的多线程吗？碰到一个具体情况如何判断，两种方式优缺点分别在哪？

 **Python中的多线程没有真正实现多线程**，**GIL**。Python代码的执行由Python虚拟机（解释器）来控制，Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。

所以我们的代码是CPU密集型的，那么这个时候的多线程代码很有可能是线程执行的。因为在任意时间只有一个Python解释器来解释Python 字节码。

但如果我们的代码是IO密集型的话，这个时候多线程的效率就可以很明显的体现出来了，可以很明显的提高效率，比如python爬虫。

## 0x3 分析一下为什么朴素贝叶斯的效果不太好，说一下朴素贝叶斯和决策树随机森林的模型的主要区别。

朴素贝叶斯可能主要是基于概率计算的，而我的项目里正负样本差距太大，导致分析的结果差别很大。



随机森林和决策树可能主要是机遇信息增益这快比较多，来进行分支判别。



## 0x4 说一下编译器和解释器的区别

解释器：一边编译，一边运行。一段程序在解释器中运行可能会被编译很多遍，因为每次运行这段程序时，都要重新编译，所以开销比较大。（Python，Perl，JavaScript等一些脚本语言)

**在程序执行时，解释器读取一句源代码之后，先进行词法分析和语法分析，再将源代码转换为解释器能够执行的中间代码（字节码），最后，由解释器将中间代码解释为可执行的机器指令。**

编译器：先将源代码编译为不同的CPU可以运行的机器码，在CPU上运行，所以速度很快。流程为：

**源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables)。**

正因为上述的原因，需要匹配不同的CPU架构，所以库文件和操作系统等都要匹配，所以这类语言是不跨平台的（C、C++等）。

参考1：https://blog.csdn.net/touzani/article/details/1625760

参考2：http://www.opython.com/1355.html

## 0x5 说一下生成式和判别式的区别，从数学上说一下

生成式模型：生成式模型是对x和y的联合概率p(x,y)进行建模，然后通过贝叶斯公式来求p(y/x)，最后选取使得p(y/x)最大的yi作为最后的结果。是**联合概率**。

判别式模型：判别式模型会对p(y/x)建模。是**条件概率**。

生成式模型算法有：判别式分析，朴素贝叶斯，KNN，混合高斯模型，隐马尔可夫模型（HMM），贝叶斯网络，深度信念网络，马尔可夫随机场。

判别式模型算法有：线性回归，逻辑回归，神经网络，SVM，高斯过程，条件随机场，CART

参考：https://www.cnblogs.com/kemaswill/p/3427422.html