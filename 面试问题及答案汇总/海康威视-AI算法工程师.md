[TOC]

# 海康威视-AI算法工程师

海康威视主要是做视频监控，所以会大量的运用到图片的处理技术。所以所问的问题也基本和图片的一些原理和操作相关，然后是与深度学习结合起来做检测识别，猜测主要也是CNN.

另外，主要是用C++来实现相关的算法问题。所以对项目、算法和Python不是特别看重。

## 1. 腐蚀和膨胀

直观上来看，腐蚀和膨胀一个是缩小了图像，另一个增大了图像。具体来说；

有一个图像X，有一个结构元素B，B平移的点记作a，如果：

1、B平移后的元$B^v$**包含于**X，那么a的集合则称作X腐蚀后的结果。

2、B平移后的元$B^v$**击中**X，那么a的集合则称作X膨胀后的结果。

参考：

https://blog.csdn.net/junpengxue/article/details/79958651

https://blog.csdn.net/zqx951102/article/details/82997588

## 2. 图像的缩放算法

### 1、最近邻算法

在待求像素的（待插值图的）四邻像素中，将距离待求像素最近的邻像素灰度赋给待求像素。

**优点：**最常见，最通用的算法之一，计算量很小，算法简单，因此运算速度较快。

**缺点：**效果不好，放大图像时会出现严重的马赛克，缩小图像则会严重失真。它仅使用离待测采样点最近的像素的灰度值作为该采样点的灰度值，而没考虑其他相邻像素点的影响，因而重新采样后灰度值有明显的不连续性，图像质量损失较大，会产生明显的马赛克和锯齿现象。

### 2、双线性插值（Bilinear算法）

双线性插值即在两个方向分别进行一次线性插值，通过四个相邻像素插值得到待求像素。

**优点：**最常见，最通用的算法之一，效果比最近邻插值法好。计算量较小，运算速度较快。图像连续性较好。双线性插值法效果要好于最近邻插值，只是计算量稍大一些，算法复杂些，程序运行时间也稍长些，但缩放后图像质量高，基本克服了最近邻插值灰度值不连续的特点，因为它考虑了待测采样点周围四个直接邻点对该采样点的相关性影响。

**缺点：**放大时图像较为模糊，细节损失较严重。它仅考虑待测样点周围四个直接邻点灰度值的影响, 而未考虑到各邻点间灰度值变化率的影响, 因此具有低通滤波器的性质, 从而导致缩放后图像的高频分量受到损失, 图像边缘在一定程度上变得较为模糊。用此方法缩放后的输出图像与输入图像相比, 存在由于插值函数设计考虑不周而产生的图像质量受损与计算精度不高的问题。

### 3、双三次插值（Bicubic算法）

双三次插值是二维空间中最常用的插值方法。在这种方法中，函数f在点 (x,y) 的值可以通过矩形网格中最近的十六个采样点的加权平均得到，在这里需要使用两个多项式插值三次函数，每个方向使用一个。

**优点：**立方卷积插值计算量最大，算法也是最为复杂的。在几何运算中，双线性内插法的平滑作用可能会使图像的细节产生退化，在进行放大处理时，这种影响更为明显。在其他应用中，双线性插值的斜率不连续性会产生不希望的结果。立方卷积插值不仅考虑到周围四个直接相邻像素点灰度值的影响，还考虑到它们灰度值变化率的影响。因此克服了最近邻算法和双线性算法的不足之处，能够产生比双线性插值更为平滑的边缘，计算精度很高，处理后的图像像质损失最少，效果是最佳的。

**缺点：**立方卷积插值计算量较大，算法相较双线性算法更为复杂。

### 4、Lanczos算法

类似于双三次插值，对4x4的像素卷积处理，得到待求像素。

**优点：**得到的图像在抗锯齿和保留锐利边缘的效果较好。

**缺点：**相当于立方卷积插值，计算量较大，算法相较双线性算法更为复杂。

另外还有NEDI算法、EP2X算法、HQX算法、Google SR算法等。

参考：

https://blog.csdn.net/allen_sdz/article/details/89166363



## 3. 图像特征提取算子

方向梯度直方图（Histogram of Oriented Gradient, HOG）特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子。它通过计算和统计图像局部区域的梯度方向直方图来构成特征。Hog特征结合SVM分类器已经被广泛应用于图像识别中，尤其在行人检测中获得了极大的成功。

参考：

https://blog.csdn.net/a133521741/article/details/79237776



## 4. 卷积的作用

卷积从图像上来讲就是：**空间上的“加权求和”**

对于一些时序问题的卷积可以看作：**时间上的“加权求和”**

至于为什么不用全连接，因为放置参数爆炸。

卷积问题考察的较多，参考：

https://blog.csdn.net/qq_42219077/article/details/88043384

https://blog.csdn.net/libing_zeng/article/details/78209297



## 5. L1和L2正则化

**L1和L2是正则化项，又叫做罚项，是为了限制模型的参数，防止模型过拟合而加在损失函数后面的一项。**

**L1是模型各个参数的绝对值之和。L2是模型各个参数的平方和的开方值。**

L1会趋向于产生少量的特征，而其他的特征都是0.

因为最优的参数值很大概率出现在坐标轴上，这样就会导致某一维的权重为0 ，产生稀疏权重矩阵

L2会选择更多的特征，这些特征都会接近于0。  

最优的参数值很小概率出现在坐标轴上，因此每一维的参数都不会是0。当最小化||w||时，就会使每一项趋近于0

 参考：

https://www.cnblogs.com/lyr2015/p/8718104.html

https://blog.csdn.net/red_stone1/article/details/80755144



## 6. 随机梯度下降的优化算法

参数的自适应学习率的方法。

参考：

https://blog.csdn.net/qq_35860352/article/details/80772142

https://blog.csdn.net/u013453936/article/details/79004264



## 7. 排序算法总结

快排的时间复杂度是$O(nlogn)$

参考：

https://blog.csdn.net/hellozhxy/article/details/79911867



## 8. C++ const和宏定义的区别

### 1、编译器处理方式 

define – 在预处理阶段进行替换 
const – 在编译时确定其值

### 2、类型检查 
define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
const – 有数据类型，编译时会进行类型检查

### 3、内存空间 
define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

### 4、其他 
在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 
宏替换只作替换，不做计算，不做表达式求解。

参考：

https://blog.csdn.net/yingyujianmo/article/details/51206460



## 9. 哈希表解决碰撞的几个方法

1、开放地址寻址法

2、再哈希法

3、链地址法（拉链法）

4、建立一个公共溢出区

参考：

https://blog.csdn.net/hotchange/article/details/80159671

https://blog.csdn.net/fhb1922702569/article/details/77506227









