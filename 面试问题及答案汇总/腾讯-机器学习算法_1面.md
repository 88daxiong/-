# 腾讯-机器学习算法_1

## 0x1 python2和python3的区别

1. 编码问题。`pyhon2`是`ASCII`编码（这是是`python2`经常出现问题的原因之一），`python3`改为了`Unicode`编码。所以在`python3`最开始不用加入`#coding: utf-8`

2. 整除。`python2`除法会直接取整，`python3`整除是浮点数。

   ```python
   # python2整除；
   >>> 1/2 
   0
   >>> 1.0/2.0
   0.5
   
   # python3整除；
   >>> 1/2
   0.5
   ```

3. 语句变函数，如`exec`,`print`。`python2`的`print`是一个**语法结构**，`python3`的`print`是个**函数**。

4. `input`的问题。`python2`不能接受非字符串的输入，`python3`的`input`会将用户所有的输入都当作字符串对待。

5. 迭代器。`python2`的`xrange`相当于`python3`中的`range`。

6. `Nonlocal关键字`。python3加入了`nonlocal`关键字，可以在嵌套函数外访问嵌套函数里的变量。

7. Await async(异步IO)

参考：https://www.cnblogs.com/feifeifeisir/p/9599218.html



## 0x2 浅拷贝和深拷贝的区别

**浅拷贝只是复制了对象的引用地址**，两个对象指向同一个内存地址，所以修改其中任意的值，另一个都会**随之改变**；

**深拷贝是将对象及值复制过来**，两个对象修改其中任意的值另外一个值**不会变化**。

```python
In [1]: import copy

In [2]: atuple=(1,2,3,[4,5])

In [3]: b = copy.copy(atuple)  # 浅拷贝，b和atuple其实是同一个，一个改变另外一个跟着改变

In [4]: c = copy.deepcopy(atuple) # 深拷贝，c和atuple不一样，一个改变另外一个不改变

In [5]: print(atuple, b, c)
(1, 2, 3, [4, 5]) (1, 2, 3, [4, 5]) (1, 2, 3, [4, 5])

In [6]: atuple[3].append(6)

In [7]: print(atuple, b, c)
(1, 2, 3, [4, 5, 6]) (1, 2, 3, [4, 5, 6]) (1, 2, 3, [4, 5])

In [8]: c[3].append(10)

In [9]: print(atuple, b, c)
(1, 2, 3, [4, 5, 6]) (1, 2, 3, [4, 5, 6]) (1, 2, 3, [4, 5, 10])
```



## 0x3 多线程和多进程的区别，应该如何选择使用？

大量需要CPU计算，需要稳定性的时候，选择进程（比如web程序）；

大量切换CPU的时候，与用户IO交互多的，选择线程（比如，图像处理，算法处理）；

| **对比维度**   | **多进程**                                                   | **多线程**                                                   | **总结** |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 数据共享、同步 | 数据共享复杂，需要用IPC；数据是分开的，同步简单              | 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 | 各有优势 |
| 内存、CPU      | 占用内存多，切换复杂，CPU利用率低                            | 占用内存少，切换简单，CPU利用率高                            | 线程占优 |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度很快                                 | 线程占优 |
| 编程、调试     | 编程简单，调试简单                                           | 编程复杂，调试复杂                                           | 进程占优 |
| 可靠性         | 进程间不会互相影响                                           | 一个线程挂掉将导致整个进程挂掉                               | 进程占优 |
| 分布式         | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布式                                             | 进程占优 |

参考：https://www.cnblogs.com/virusolf/p/5458325.html



## 0x4 进程通信的方式

有5种方式：

1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO（命名管道）：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

6.套接字（socket）：

参考1：https://www.cnblogs.com/zgq0/p/8780893.html

参考2：https://blog.csdn.net/wm12345645/article/details/82381407

python提供了多种进程通信的方式，主要Queue和Pipe这两种方式，Queue用于多个进程间实现通信，Pipe是两个进程的通信

参考：https://www.cnblogs.com/guguobao/p/9398653.html



## 0x5 TCP和UDP的区别

- TCP 是面向连接的，UDP 是面向无连接的
- UDP程序结构较简单
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，UDP 可能丢包
- TCP 保证数据顺序，UDP 不保证

参考：https://blog.csdn.net/zhang6223284/article/details/81414149



## 0x6 决策树有那几种类型

ID3、C4.5、CART等三种。

**ID3算法**的核心是在决策树各个子节点上应用信息增益准则选择特征，递归的构建决策树，具体方法是:从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点；再对子节点递归调用以上方法，构建决策树。直到所有特征的信息增益均很小或没有特征可以选择为止。最后得到一个决策树。

缺点在于：**用信息增益选择属性时偏向于选择分枝比较多的属性值，即取值多的属性**。**不能处理连续属性。**

**C4.5是对ID3的改进**。主要有以下改进：

> 用信息增益来选择属性；
>
> 在决策树的构造过程中对树进行剪枝；
>
> 对非离散数据也能处理；
>
> 能够对不完整数据进行处理；

**CART算法**选择分裂属性的方式是比较有意思的，首先计算不纯度，然后利用不纯度计算Gini指标。以满意度预警模型为例，计算自变量故障原因的Gini指标时，先按照故障原因可能的子集进行划分

参考1:https://blog.csdn.net/LA401088242/article/details/89034077

参考2:https://blog.csdn.net/gumpeng/article/details/51397737



## 0x7 Mysql索引结构

Mysql索引一般可以有：BTree索引，哈希索引，全文索引等；一般采取B+树作为索引。

> **B+树磁盘读写代价更低**：因为B+树的所有**非叶子节点只会存放索引信息**，而**真正的数据信息都只存放在叶子节点**中，这样一来，每个非叶子节点存放的索引信息就更多，一次磁盘IO就可以读取更多的索引信息到内存中，可以减少磁盘IO的次数。
>
> **B+树查询效率更加稳定**：由于非叶子节点只存索引信息，而没有真正的数据信息，所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
>
> **B+树更加适合在区间查询的情况**：由于B+树的数据都存储在叶子结点中，非叶子结点均为索引，只需要扫一遍叶子结点即可得到所有数据信息，但是B树因为其非叶子结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

参考1：https://my.oschina.net/edwardge/blog/1934165

参考2:https://blog.csdn.net/caohao0591/article/details/80962308







